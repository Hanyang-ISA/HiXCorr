// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: results.proto

#ifndef PROTOBUF_results_2eproto__INCLUDED
#define PROTOBUF_results_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "peptides.pb.h"
#include "spectrum.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_results_2eproto();
void protobuf_AssignDesc_results_2eproto();
void protobuf_ShutdownFile_results_2eproto();

class Match;
class Stats;
class Results;

// ===================================================================

class Match : public ::google::protobuf::Message {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  void Swap(Match* other);

  // implements Message ----------------------------------------------

  Match* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double xcorr = 1;
  inline bool has_xcorr() const;
  inline void clear_xcorr();
  static const int kXcorrFieldNumber = 1;
  inline double xcorr() const;
  inline void set_xcorr(double value);

  // optional .pb.Peptide peptide = 2;
  inline bool has_peptide() const;
  inline void clear_peptide();
  static const int kPeptideFieldNumber = 2;
  inline const ::pb::Peptide& peptide() const;
  inline ::pb::Peptide* mutable_peptide();
  inline ::pb::Peptide* release_peptide();
  inline void set_allocated_peptide(::pb::Peptide* peptide);

  // @@protoc_insertion_point(class_scope:pb.Match)
 private:
  inline void set_has_xcorr();
  inline void clear_has_xcorr();
  inline void set_has_peptide();
  inline void clear_has_peptide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double xcorr_;
  ::pb::Peptide* peptide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_results_2eproto();
  friend void protobuf_AssignDesc_results_2eproto();
  friend void protobuf_ShutdownFile_results_2eproto();

  void InitAsDefaultInstance();
  static Match* default_instance_;
};
// -------------------------------------------------------------------

class Stats : public ::google::protobuf::Message {
 public:
  Stats();
  virtual ~Stats();

  Stats(const Stats& from);

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stats& default_instance();

  void Swap(Stats* other);

  // implements Message ----------------------------------------------

  Stats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stats& from);
  void MergeFrom(const Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional double sum = 2;
  inline bool has_sum() const;
  inline void clear_sum();
  static const int kSumFieldNumber = 2;
  inline double sum() const;
  inline void set_sum(double value);

  // optional double sum_squares = 3;
  inline bool has_sum_squares() const;
  inline void clear_sum_squares();
  static const int kSumSquaresFieldNumber = 3;
  inline double sum_squares() const;
  inline void set_sum_squares(double value);

  // @@protoc_insertion_point(class_scope:pb.Stats)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_sum_squares();
  inline void clear_has_sum_squares();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double sum_;
  double sum_squares_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_results_2eproto();
  friend void protobuf_AssignDesc_results_2eproto();
  friend void protobuf_ShutdownFile_results_2eproto();

  void InitAsDefaultInstance();
  static Stats* default_instance_;
};
// -------------------------------------------------------------------

class Results : public ::google::protobuf::Message {
 public:
  Results();
  virtual ~Results();

  Results(const Results& from);

  inline Results& operator=(const Results& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Results& default_instance();

  void Swap(Results* other);

  // implements Message ----------------------------------------------

  Results* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Results& from);
  void MergeFrom(const Results& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.Spectrum spectrum = 1;
  inline bool has_spectrum() const;
  inline void clear_spectrum();
  static const int kSpectrumFieldNumber = 1;
  inline const ::pb::Spectrum& spectrum() const;
  inline ::pb::Spectrum* mutable_spectrum();
  inline ::pb::Spectrum* release_spectrum();
  inline void set_allocated_spectrum(::pb::Spectrum* spectrum);

  // optional int32 charge = 2;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 2;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);

  // repeated .pb.Match matches = 3;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 3;
  inline const ::pb::Match& matches(int index) const;
  inline ::pb::Match* mutable_matches(int index);
  inline ::pb::Match* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Match >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Match >*
      mutable_matches();

  // optional int32 spectrum_index = 4;
  inline bool has_spectrum_index() const;
  inline void clear_spectrum_index();
  static const int kSpectrumIndexFieldNumber = 4;
  inline ::google::protobuf::int32 spectrum_index() const;
  inline void set_spectrum_index(::google::protobuf::int32 value);

  // optional .pb.Stats stats = 5;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 5;
  inline const ::pb::Stats& stats() const;
  inline ::pb::Stats* mutable_stats();
  inline ::pb::Stats* release_stats();
  inline void set_allocated_stats(::pb::Stats* stats);

  // @@protoc_insertion_point(class_scope:pb.Results)
 private:
  inline void set_has_spectrum();
  inline void clear_has_spectrum();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_spectrum_index();
  inline void clear_has_spectrum_index();
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::Spectrum* spectrum_;
  ::google::protobuf::RepeatedPtrField< ::pb::Match > matches_;
  ::google::protobuf::int32 charge_;
  ::google::protobuf::int32 spectrum_index_;
  ::pb::Stats* stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_results_2eproto();
  friend void protobuf_AssignDesc_results_2eproto();
  friend void protobuf_ShutdownFile_results_2eproto();

  void InitAsDefaultInstance();
  static Results* default_instance_;
};
// ===================================================================


// ===================================================================

// Match

// optional double xcorr = 1;
inline bool Match::has_xcorr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Match::set_has_xcorr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Match::clear_has_xcorr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Match::clear_xcorr() {
  xcorr_ = 0;
  clear_has_xcorr();
}
inline double Match::xcorr() const {
  return xcorr_;
}
inline void Match::set_xcorr(double value) {
  set_has_xcorr();
  xcorr_ = value;
}

// optional .pb.Peptide peptide = 2;
inline bool Match::has_peptide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Match::set_has_peptide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Match::clear_has_peptide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Match::clear_peptide() {
  if (peptide_ != NULL) peptide_->::pb::Peptide::Clear();
  clear_has_peptide();
}
inline const ::pb::Peptide& Match::peptide() const {
  return peptide_ != NULL ? *peptide_ : *default_instance_->peptide_;
}
inline ::pb::Peptide* Match::mutable_peptide() {
  set_has_peptide();
  if (peptide_ == NULL) peptide_ = new ::pb::Peptide;
  return peptide_;
}
inline ::pb::Peptide* Match::release_peptide() {
  clear_has_peptide();
  ::pb::Peptide* temp = peptide_;
  peptide_ = NULL;
  return temp;
}
inline void Match::set_allocated_peptide(::pb::Peptide* peptide) {
  delete peptide_;
  peptide_ = peptide;
  if (peptide) {
    set_has_peptide();
  } else {
    clear_has_peptide();
  }
}

// -------------------------------------------------------------------

// Stats

// optional int32 count = 1;
inline bool Stats::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stats::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stats::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stats::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Stats::count() const {
  return count_;
}
inline void Stats::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional double sum = 2;
inline bool Stats::has_sum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stats::set_has_sum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stats::clear_has_sum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stats::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double Stats::sum() const {
  return sum_;
}
inline void Stats::set_sum(double value) {
  set_has_sum();
  sum_ = value;
}

// optional double sum_squares = 3;
inline bool Stats::has_sum_squares() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stats::set_has_sum_squares() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stats::clear_has_sum_squares() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stats::clear_sum_squares() {
  sum_squares_ = 0;
  clear_has_sum_squares();
}
inline double Stats::sum_squares() const {
  return sum_squares_;
}
inline void Stats::set_sum_squares(double value) {
  set_has_sum_squares();
  sum_squares_ = value;
}

// -------------------------------------------------------------------

// Results

// optional .pb.Spectrum spectrum = 1;
inline bool Results::has_spectrum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Results::set_has_spectrum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Results::clear_has_spectrum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Results::clear_spectrum() {
  if (spectrum_ != NULL) spectrum_->::pb::Spectrum::Clear();
  clear_has_spectrum();
}
inline const ::pb::Spectrum& Results::spectrum() const {
  return spectrum_ != NULL ? *spectrum_ : *default_instance_->spectrum_;
}
inline ::pb::Spectrum* Results::mutable_spectrum() {
  set_has_spectrum();
  if (spectrum_ == NULL) spectrum_ = new ::pb::Spectrum;
  return spectrum_;
}
inline ::pb::Spectrum* Results::release_spectrum() {
  clear_has_spectrum();
  ::pb::Spectrum* temp = spectrum_;
  spectrum_ = NULL;
  return temp;
}
inline void Results::set_allocated_spectrum(::pb::Spectrum* spectrum) {
  delete spectrum_;
  spectrum_ = spectrum;
  if (spectrum) {
    set_has_spectrum();
  } else {
    clear_has_spectrum();
  }
}

// optional int32 charge = 2;
inline bool Results::has_charge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Results::set_has_charge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Results::clear_has_charge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Results::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 Results::charge() const {
  return charge_;
}
inline void Results::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// repeated .pb.Match matches = 3;
inline int Results::matches_size() const {
  return matches_.size();
}
inline void Results::clear_matches() {
  matches_.Clear();
}
inline const ::pb::Match& Results::matches(int index) const {
  return matches_.Get(index);
}
inline ::pb::Match* Results::mutable_matches(int index) {
  return matches_.Mutable(index);
}
inline ::pb::Match* Results::add_matches() {
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Match >&
Results::matches() const {
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Match >*
Results::mutable_matches() {
  return &matches_;
}

// optional int32 spectrum_index = 4;
inline bool Results::has_spectrum_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Results::set_has_spectrum_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Results::clear_has_spectrum_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Results::clear_spectrum_index() {
  spectrum_index_ = 0;
  clear_has_spectrum_index();
}
inline ::google::protobuf::int32 Results::spectrum_index() const {
  return spectrum_index_;
}
inline void Results::set_spectrum_index(::google::protobuf::int32 value) {
  set_has_spectrum_index();
  spectrum_index_ = value;
}

// optional .pb.Stats stats = 5;
inline bool Results::has_stats() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Results::set_has_stats() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Results::clear_has_stats() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Results::clear_stats() {
  if (stats_ != NULL) stats_->::pb::Stats::Clear();
  clear_has_stats();
}
inline const ::pb::Stats& Results::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::pb::Stats* Results::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::pb::Stats;
  return stats_;
}
inline ::pb::Stats* Results::release_stats() {
  clear_has_stats();
  ::pb::Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void Results::set_allocated_stats(::pb::Stats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_results_2eproto__INCLUDED
